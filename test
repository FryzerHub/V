-- Key system v3
-- FRYZER HUB Key System
-- Dual verification: Simple keys + Keys with expiry time

local KEY_CHECK_URL = "https://raw.githubusercontent.com/FryzerHub/Key-system-gui/refs/heads/main/Universal%20key"
local EXPIRY_CHECK_URL = "https://raw.githubusercontent.com/FryzerHub/Key-system-gui/refs/heads/main/expiry_keys.json"
local GET_KEY_URL = "https://website-flame-tau-62.vercel.app/"
local DISCORD_INVITE = "https://discord.com/invite/UKYHGddQD3"

--! Your Main Script Function - REPLACE THIS WITH YOUR ACTUAL CODE
local function executeMainScript()
    -- PUT YOUR MAIN SCRIPT CODE HERE
    
-- Fryzer Hub for Plants vs Brainrot v2
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
WindUI:SetNotificationLower(true)

WindUI:AddTheme({
    Name = "Blue Theme",
    Accent = Color3.fromRGB(37, 99, 235),
    Dialog = Color3.fromRGB(15, 23, 42),
    Outline = Color3.fromRGB(59, 130, 246),
    Text = Color3.fromRGB(248, 250, 252),
    Placeholder = Color3.fromRGB(100, 116, 139),
    Background = Color3.fromRGB(15, 23, 42),
    Button = Color3.fromRGB(30, 58, 138),
    Icon = Color3.fromRGB(147, 197, 253)
})

local Window = WindUI:CreateWindow({
    Title = "Fryzer Hub",
    Icon = "",
    Author = "Join Discord",
    Folder = "AutoBuyHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Blue Theme",
    Resizable = true,
    SideBarWidth = 200,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

Window:Tag({
    Title = "v4.9",
    Color = Color3.fromHex("#30ff6a"),
    Radius = 8,
})

Window:Tag({
    Title = "PVB",
    Color = Color3.fromHex("#ff0000"),
    Radius = 10,
})

local InfoTab = Window:Tab({
    Title = "Info",
    Icon = "info",
    Locked = false,
})

InfoTab:Select()

-- ==================== PLAYER INFORMATION SECTION ====================
local Sectiontest = InfoTab:Section({
    Title = "Player Information Dashboard",
    Icon = "user-check",
})

InfoTab:Paragraph({
    Title = "Player Information Dashboard",
    Desc = "Complete player details, game information, and community access",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer
local PlayerName = Player.DisplayName ~= "" and Player.DisplayName or Player.Name
local AccountAge = Player.AccountAge
local GameName = "Unknown Game"
pcall(function()
    GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name
end)

InfoTab:Paragraph({
    Title = "üë§ " .. PlayerName,
    Desc = string.format(
        "üè∑Ô∏è Username: @%s\nüéÇ Account Age: %d days\nüÜî User ID: %d\nüéÆ Current Game: %s\nüë• Server: %d/%d players\nüìç Region: %s",
        Player.Name, AccountAge, Player.UserId, GameName,
        #Players:GetPlayers(), Players.MaxPlayers,
        game:GetService("LocalizationService").RobloxLocaleId
    ),
    Color = "Blue",
    Image = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. Player.UserId .. "&width=150&height=150&format=png",
    ImageSize = 52,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

InfoTab:Divider()

-- ==================== DISCORD COMMUNITY SECTION ====================
local DiscordSection = InfoTab:Section({
    Title = "Join Our Discord Community",
    Icon = "users",
})

InfoTab:Paragraph({
    Title = "üéÆ Connect & Engage",
    Desc = "Join thousands of players in our Discord community for updates, support, and exclusive content!",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

-- Discord API Configuration
local InviteCode = "UKYHGddQD3"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"

-- Universal HTTP Request Handler
local function HttpRequest(data)
    if syn and syn.request then
        return syn.request(data)
    elseif http and http.request then
        return http.request(data)
    elseif http_request then
        return http_request(data)
    elseif request then
        return request(data)
    else
        error("Your executor does not support HTTP requests.")
    end
end

local DiscordResponse
local DiscordErrorMessage = nil
local DiscordInfoParagraph

-- Fetch Discord Information
xpcall(function()
    local req = HttpRequest({
        Url = DiscordAPI,
        Method = "GET",
        Headers = {
            ["Accept"] = "application/json"
        }
    })

    if req and req.Body then
        DiscordResponse = HttpService:JSONDecode(req.Body)
    else
        error("Invalid response from Discord API.")
    end
end, function(err)
    warn("Error fetching Discord info: " .. tostring(err))
    DiscordErrorMessage = tostring(err)
    DiscordResponse = nil
end)

-- Display Discord Information
if DiscordResponse and DiscordResponse.guild then
    local guildName = DiscordResponse.guild.name or "Unknown Server"
    local memberCount = DiscordResponse.approximate_member_count or 0
    local onlineCount = DiscordResponse.approximate_presence_count or 0
    
    local ParagraphConfig = {
        Title = "üî∑ " .. guildName,
        Desc = 
            'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(memberCount) ..
            '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(onlineCount) ..
            '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. math.floor((onlineCount / math.max(memberCount, 1)) * 100) .. '% active',
        Color = "Red",
        ImageSize = 52,
        Buttons = {
            {
                Icon = "link",
                Title = "Copy Invite",
                Callback = function()
                    pcall(function()
                        setclipboard("https://discord.gg/" .. InviteCode)
                        WindUI:Notify({
                            Title = "‚úÖ Copied!",
                            Content = "Discord invite copied to clipboard.",
                            Duration = 3,
                            Icon = "copy",
                        })
                    end)
                end
            },
            {
                Icon = "refresh-cw",
                Title = "Update Stats",
                Callback = function()
                    xpcall(function()
                        local upd = HttpRequest({
                            Url = DiscordAPI,
                            Method = "GET",
                            Headers = {
                                ["Accept"] = "application/json"
                            }
                        })
                        if upd and upd.Body then
                            local UpdatedResponse = HttpService:JSONDecode(upd.Body)
                            if UpdatedResponse and UpdatedResponse.guild then
                                local newMembers = UpdatedResponse.approximate_member_count or 0
                                local newOnline = UpdatedResponse.approximate_presence_count or 0
                                local activity = math.floor((newOnline / math.max(newMembers, 1)) * 100)
                                
                                DiscordInfoParagraph:SetDesc(
                                    'üìä <font color="#3b82f6"><b>Members:</b></font> ' .. tostring(newMembers) ..
                                    '\nüü¢ <font color="#10b981"><b>Online:</b></font> ' .. tostring(newOnline) ..
                                    '\nüìà <font color="#f59e0b"><b>Activity:</b></font> ' .. activity .. '% active'
                                )
                                WindUI:Notify({
                                    Title = "üîÑ Updated!",
                                    Content = "Discord stats refreshed successfully.",
                                    Duration = 2,
                                    Icon = "check",
                                })
                            end
                        end
                    end, function(err)
                        warn("Error updating Discord info: " .. tostring(err))
                        WindUI:Notify({
                            Title = "‚ö†Ô∏è Update Failed",
                            Content = "Could not refresh Discord stats.",
                            Duration = 3,
                            Icon = "alert-circle",
                        })
                    end)
                end
            }
        }
    }

    -- Add guild icon if available
    if DiscordResponse.guild.icon then
        ParagraphConfig.Image = "https://cdn.discordapp.com/icons/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.icon .. ".png?size=256"
    end

    -- Add banner if available
    if DiscordResponse.guild.banner then
        ParagraphConfig.Thumbnail = "https://cdn.discordapp.com/banners/" .. DiscordResponse.guild.id .. "/" .. DiscordResponse.guild.banner .. ".png?size=512"
        ParagraphConfig.ThumbnailSize = 80
    end

    DiscordInfoParagraph = InfoTab:Paragraph(ParagraphConfig)
else
    InfoTab:Paragraph({
        Title = "‚ö†Ô∏è Discord Info Unavailable",
        Desc = DiscordErrorMessage or "Unable to fetch Discord server information. Try again later!",
        Color = "Blue",
        ImageSize = 26,
    })
end

-- Quick Action Button
InfoTab:Button({
    Title = "üìã Copy Discord Link",
    Desc = "Copy invite link to clipboard",
    Locked = false,
    Callback = function()
        setclipboard("https://discord.gg/" .. InviteCode)
        WindUI:Notify({
            Title = "‚úÖ Link Copied!",
            Content = "Discord invite copied to clipboard",
            Duration = 3,
            Icon = "copy",
        })
    end
})

InfoTab:Space()

-- Configuration Variables for Seeds
local AUTO_BUY_ENABLED = false
local SELECTED_ITEMS = {}
local CLICK_DELAY = 0.1
local buyRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BuyItem")

-- Configuration Variables for Gear
local AUTO_BUY_GEAR_ENABLED = false
local SELECTED_GEAR = {}
local GEAR_CLICK_DELAY = 0.1
local buyGearRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("BuyGear")

-- Available items (you can add more here)
local AVAILABLE_ITEMS = {
    "Cactus Seed",
    "Watermelon Seed",
    "Tomatrio Seed",
    "Sunflower Seed",
    "Strawberry Seed",
    "Shroombino Seed",
    "Pumpkin Seed",
    "Mr Carrot Seed",
    "Mango Seed",
    "King Limone Seed",
    "Grape Seed",
    "Eggplant Seed",
    "Dragon Fruit Seed",
    "Cocotank Seed",
    "Carnivorous Plant Seed",
}

-- Available gear items
local AVAILABLE_GEAR = {
    "Water Bucket",
    "Frost Grenade",
    "Frost Blower",
    "Carrot Launcher",
    "Banana Gun",
}

-- Function to buy seeds
local function clickButton(itemName)
    pcall(function()
        local args = {itemName, true}
        buyRemote:FireServer(unpack(args))
    end)
end

-- Function to buy gear
local function clickGearButton(gearName)
    pcall(function()
        local args = {gearName, true}
        buyGearRemote:FireServer(unpack(args))
    end)
end

-- Main auto-buy loop for seeds
local function startAutoBuy()
    spawn(function()
        while AUTO_BUY_ENABLED do
            if #SELECTED_ITEMS > 0 then
                for _, itemName in ipairs(SELECTED_ITEMS) do
                    clickButton(itemName)
                    wait(CLICK_DELAY / #SELECTED_ITEMS)
                end
            end
            wait(0.01)
        end
    end)
end

-- Main auto-buy loop for gear
local function startGearAutoBuy()
    spawn(function()
        while AUTO_BUY_GEAR_ENABLED do
            if #SELECTED_GEAR > 0 then
                for _, gearName in ipairs(SELECTED_GEAR) do
                    clickGearButton(gearName)
                    wait(GEAR_CLICK_DELAY / #SELECTED_GEAR)
                end
            end
            wait(0.01)
        end
    end)
end

-- Create Main Tab
local MainTab = Window:Tab({
    Title = "Auto",
    Icon = "repeat",
    Locked = false,
})

-- Section: Auto Buy Controls
local ControlSection = MainTab:Section({
    Title = "Auto Buy Controls",
    Icon = "shopping-cart",
})

local ControlSectionseeds = MainTab:Section({
    Title = "Seeds Auto Buyer",
    Icon = "",
})

-- Multi-Select Dropdown for Items
local ItemDropdown = MainTab:Dropdown({
    Title = "Select Items to Buy",
    Values = AVAILABLE_ITEMS,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedItems)
        SELECTED_ITEMS = selectedItems
        WindUI:Notify({
            Title = "Items Updated",
            Content = #selectedItems .. " item(s) selected for auto-buy",
            Duration = 2,
            Icon = "check",
        })
    end
})

-- Toggle for Auto Buy
local AutoBuyToggle = MainTab:Toggle({
    Title = "Enable Auto Buy",
    Desc = "Automatically purchase selected items",
    Default = false,
    Callback = function(value)
        AUTO_BUY_ENABLED = value
        
        if value then
            if #SELECTED_ITEMS == 0 then
                WindUI:Notify({
                    Title = "No Items Selected",
                    Content = "Please select items before enabling auto-buy",
                    Duration = 3,
                    Icon = "alert-triangle",
                })
                AutoBuyToggle:SetValue(false)
                return
            end
            
            WindUI:Notify({
                Title = "Auto Buy Started",
                Content = "Buying " .. #SELECTED_ITEMS .. " item(s) continuously",
                Duration = 3,
                Icon = "play",
            })
            startAutoBuy()
        else
            WindUI:Notify({
                Title = "Auto Buy Stopped",
                Content = "Auto-buy has been disabled",
                Duration = 2,
                Icon = "stop-circle",
            })
        end
    end
})

MainTab:Space()

local ControlSectionGear = MainTab:Section({
    Title = "Gear Auto Buyer",
    Icon = "",
})

-- Multi-Select Dropdown for Gear
local GearDropdown = MainTab:Dropdown({
    Title = "Select Gear to Buy",
    Values = AVAILABLE_GEAR,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedGear)
        SELECTED_GEAR = selectedGear
        WindUI:Notify({
            Title = "Gear Updated",
            Content = #selectedGear .. " gear item(s) selected for auto-buy",
            Duration = 2,
            Icon = "check",
        })
    end
})

-- Toggle for Gear Auto Buy
local GearAutoBuyToggle = MainTab:Toggle({
    Title = "Enable Gear Auto Buy",
    Desc = "Automatically purchase selected gear items",
    Default = false,
    Callback = function(value)
        AUTO_BUY_GEAR_ENABLED = value
        
        if value then
            if #SELECTED_GEAR == 0 then
                WindUI:Notify({
                    Title = "No Gear Selected",
                    Content = "Please select gear items before enabling auto-buy",
                    Duration = 3,
                    Icon = "alert-triangle",
                })
                GearAutoBuyToggle:SetValue(false)
                return
            end
            
            WindUI:Notify({
                Title = "Gear Auto Buy Started",
                Content = "Buying " .. #SELECTED_GEAR .. " gear item(s) continuously",
                Duration = 3,
                Icon = "play",
            })
            startGearAutoBuy()
        else
            WindUI:Notify({
                Title = "Gear Auto Buy Stopped",
                Content = "Gear auto-buy has been disabled",
                Duration = 2,
                Icon = "stop-circle",
            })
        end
    end
})

MainTab:Space()

local ControlSectionGear = MainTab:Section({
    Title = "Auto system",
    Icon = "",
})

-- Remote to fire repeatedly
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local EquipBestBrainrots = ReplicatedStorage.Remotes.EquipBestBrainrots -- RemoteEvent

-- Variables for toggle and interval control
local running = false
local interval = 50 -- Default interval in seconds (from slider)

-- Toggle to start/stop the repeating fire
local ToggleTimer = MainTab:Toggle({
    Title = "Auto Equip Best Brainrots",
    Desc = "",
    Default = false,
    Callback = function(state)
        running = state
        if state then
            -- Start the repeating loop in a new thread
            spawn(function()
                while running do
                    EquipBestBrainrots:FireServer()
                    print("Fired EquipBestBrainrots remote")
                    wait(interval) -- Wait for the set interval
                end
            end)
        end
        print("Auto Equip: " .. tostring(state))
    end
})

-- Slider to control the interval (in seconds)
local Slidertimer = MainTab:Slider({
    Title = "Repeat Interval",
    Step = 1,
    Value = {
        Min = 5,  -- Minimum 5 second to avoid spam
        Max = 300,
        Default = 50,
    },
    Callback = function(value)
        interval = value
        print("Interval set to: " .. value .. " seconds")
    end
})

local CombatTab = Window:Tab({
    Title = "Combat",
    Icon = "sword",
    Locked = false,
})

-- Kill Aura Settings and Functions
local Settings = {
    Enabled = false,
    AttackSpeed = 0.05,
    TweenSpeed = 0.3,
    Distance = 3,
    HeightOffset = 15,
    InfiniteMode = true,
    AttackAllMode = true,
    RarityFilterEnabled = true,
    TargetRarities = {},
    AttackAllRarities = false,
}

-- Get folders
local MissionBrainrotsFolder = Workspace:WaitForChild("ScriptedMap"):WaitForChild("MissionBrainrots")
local AttackRemote = ReplicatedStorage.Remotes.AttacksServer.WeaponAttack
local ChangeSettingRemote = ReplicatedStorage.Remotes.ChangeSetting

-- State variables
local currentTarget = nil
local isTweening = false
local lastAttackTime = 0
local totalKills = 0
local rarityKills = {}
local mainConnection = nil
local gravityConnection = nil
local searchConnection = nil
local showOthersDisabled = false

-- Available rarities
local RARITIES = { "Rare", "Epic", "Legendary", "Mythic", "Godly", "Secret", "Limited" }

-- Function to disable ShowOthers (runs continuously when enabled)
local function manageShowOthers()
    if Settings.Enabled and not showOthersDisabled then
        pcall(function()
            ChangeSettingRemote:FireServer({
                Value = false,
                Setting = "ShowOthers"
            })
        end)
        showOthersDisabled = true
        print("[VISIBILITY] ShowOthers disabled")
    end
end

-- Function to get brainrot position
local function getPosition(obj)
    if not obj or not obj.Parent then return nil end
   
    if obj:IsA("Model") then
        local part = obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
        if part then return part.Position end
        return obj:GetPivot().Position
    elseif obj:IsA("BasePart") then
        return obj.Position
    elseif obj:IsA("Folder") then
        local part = obj:FindFirstChildWhichIsA("BasePart", true)
        if part then return part.Position end
    end
   
    return nil
end

-- Function to get brainrot rarity
local function getBrainrotRarity(brainrot)
    if not brainrot or not brainrot.Parent then return nil end
   
    local rarity = brainrot:GetAttribute("Rarity")
    if rarity then return rarity end
   
    local rarityValue = brainrot:FindFirstChild("Rarity")
    if rarityValue and rarityValue:IsA("ValueBase") then
        return rarityValue.Value
    end
   
    return nil
end

-- Function to check if brainrot matches rarity filter
local function matchesRarityFilter(brainrot)
    if not Settings.RarityFilterEnabled then return true end
    if Settings.AttackAllRarities then return true end
    if #Settings.TargetRarities == 0 then return true end
   
    local rarity = getBrainrotRarity(brainrot)
    if not rarity then return false end
   
    -- Check if rarity is in selected list
    for _, targetRarity in ipairs(Settings.TargetRarities) do
        if rarity:lower() == targetRarity:lower() then
            return true
        end
    end
   
    return false
end

-- Function to get brainrot ID
local function getBrainrotID(brainrot)
    if brainrot:IsA("Model") then
        local id = brainrot:GetAttribute("ID")
            or brainrot:GetAttribute("BrainrotID")
            or brainrot:GetAttribute("UniqueID")
            or brainrot:GetAttribute("GUID")
       
        if id then return id end
       
        local idValue = brainrot:FindFirstChild("ID")
            or brainrot:FindFirstChild("BrainrotID")
            or brainrot:FindFirstChild("UniqueID")
       
        if idValue and idValue:IsA("ValueBase") then
            return idValue.Value
        end
    end
   
    return brainrot
end

-- Function to find nearest brainrot
local function findNearest()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
   
    local playerPos = LocalPlayer.Character.HumanoidRootPart.Position
    local nearest = nil
    local nearestDist = math.huge
   
    for _, brainrot in pairs(MissionBrainrotsFolder:GetChildren()) do
        if matchesRarityFilter(brainrot) then
            local pos = getPosition(brainrot)
            if pos then
                local dist = (pos - playerPos).Magnitude
                if dist < nearestDist then
                    nearest = brainrot
                    nearestDist = dist
                end
            end
        end
    end
   
    return nearest
end

-- Function to tween to target
local function tweenToTarget(targetPos)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
   
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local direction = (targetPos - hrp.Position).Unit
    local closePos = targetPos - (direction * Settings.Distance)
    local airPos = closePos + Vector3.new(0, Settings.HeightOffset, 0)
   
    local tweenInfo = TweenInfo.new(
        Settings.TweenSpeed,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.InOut
    )
   
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(airPos, targetPos)})
   
    isTweening = true
    tween:Play()
   
    tween.Completed:Connect(function()
        isTweening = false
    end)
end

-- Function to attack all brainrots
local function attackAll()
    local missionBrainrots = {}
   
    for _, brainrot in pairs(MissionBrainrotsFolder:GetChildren()) do
        if matchesRarityFilter(brainrot) then
            local id = getBrainrotID(brainrot)
            if id then
                table.insert(missionBrainrots, id)
            end
        end
    end
   
    if #missionBrainrots > 0 then
        local args = {
            {
                NormalBrainrots = {},
                MissionBrainrots = missionBrainrots
            }
        }
       
        pcall(function()
            AttackRemote:FireServer(unpack(args))
        end)
    end
end

-- Function to attack single target
local function attack(brainrotID)
    if not brainrotID then return end
   
    local args = {
        {
            NormalBrainrots = {},
            MissionBrainrots = { brainrotID }
        }
    }
   
    pcall(function()
        AttackRemote:FireServer(unpack(args))
    end)
end

-- Function to start the kill aura
local function startKillAura()
    if mainConnection then return end
   
    print("[KILL AURA] Starting...")
    manageShowOthers()
   
    -- Main loop
    mainConnection = RunService.Heartbeat:Connect(function()
        if not Settings.Enabled then return end
       
        -- Check if target is still valid
        if currentTarget and not currentTarget.Parent then
            local rarity = getBrainrotRarity(currentTarget) or "Unknown"
            rarityKills[rarity] = (rarityKills[rarity] or 0) + 1
            totalKills = totalKills + 1
            currentTarget = nil
        end
       
        -- Find new target
        if not currentTarget or not currentTarget.Parent then
            currentTarget = findNearest()
            if currentTarget then
                local pos = getPosition(currentTarget)
                if pos then
                    tweenToTarget(pos)
                end
            else
                task.wait(0.1)
                return
            end
        end
       
        -- Keep player floating
        if currentTarget and not isTweening then
            local targetPos = getPosition(currentTarget)
            if targetPos and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = LocalPlayer.Character.HumanoidRootPart
                local currentDist = (hrp.Position - targetPos).Magnitude
               
                if currentDist > 10 then
                    tweenToTarget(targetPos)
                end
            end
        end
       
        -- Attack
        local currentTime = tick()
        if currentTime - lastAttackTime >= Settings.AttackSpeed then
            if Settings.AttackAllMode then
                attackAll()
            elseif currentTarget then
                local brainrotID = getBrainrotID(currentTarget)
                attack(brainrotID)
            end
            lastAttackTime = currentTime
        end
    end)
   
    -- Keep player in air
    gravityConnection = RunService.RenderStepped:Connect(function()
        if Settings.Enabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            hrp.Velocity = Vector3.new(hrp.Velocity.X, 0, hrp.Velocity.Z)
        end
    end)
   
    -- Auto-search loop
    searchConnection = task.spawn(function()
        while Settings.Enabled and Settings.InfiniteMode do
            task.wait(2)
            if Settings.Enabled and not currentTarget then
                currentTarget = findNearest()
            end
        end
    end)
   
    print("[KILL AURA] Started successfully!")
end

-- Function to stop the kill aura
local function stopKillAura()
    print("[KILL AURA] Stopping...")
   
    if mainConnection then
        mainConnection:Disconnect()
        mainConnection = nil
    end
   
    if gravityConnection then
        gravityConnection:Disconnect()
        gravityConnection = nil
    end
   
    if searchConnection then
        task.cancel(searchConnection)
        searchConnection = nil
    end
   
    currentTarget = nil
    isTweening = false
    showOthersDisabled = false
   
    print("[KILL AURA] Stopped!")
end

-- Combat Tab UI Elements
local MainSection = CombatTab:Section({
    Title = "Main Controls",
    Icon = "power",
})

local StatsParagraph = CombatTab:Paragraph({
    Title = "Before Enabling Kill Aura \n *Make sure to hold a bat",
    Desc = "",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

local MainToggle = CombatTab:Toggle({
    Title = "Enable Auto Attack",
    Desc = "",
    Default = false,
    Callback = function(state)
        Settings.Enabled = state
       
        if state then
            startKillAura()
            WindUI:Notify({
                Title = "Kill Aura Enabled",
                Content = "Super fast movement and spam attack activated",
                Duration = 3,
                Icon = "play",
            })
        else
            stopKillAura()
            WindUI:Notify({
                Title = "Kill Aura Disabled",
                Content = "Kill aura stopped",
                Duration = 2,
                Icon = "stop-circle",
            })
        end
       
        print("[TOGGLE] Kill Aura:", state and "ON" or "OFF")
    end
})

CombatTab:Space()

local SettingsSection = CombatTab:Section({
    Title = "Settings",
    Icon = "settings",
})

local RarityDropdown = CombatTab:Dropdown({
    Title = "Target Rarities",
    Values = RARITIES,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(selectedRarities)
        Settings.TargetRarities = selectedRarities
       
        if #selectedRarities == 0 then
            Settings.AttackAllRarities = true
            print("[RARITY] No rarities selected - Attacking ALL")
            WindUI:Notify({
                Title = "Rarity Filter",
                Content = "No rarities selected - Attacking all",
                Duration = 2,
                Icon = "info",
            })
        else
            Settings.AttackAllRarities = false
            print("[RARITY] Selected:", table.concat(selectedRarities, ", "))
            WindUI:Notify({
                Title = "Rarity Filter",
                Content = table.concat(selectedRarities, ", ") .. " selected",
                Duration = 2,
                Icon = "check",
            })
        end
    end
})

local HeightSlider = CombatTab:Slider({
    Title = "Height Offset",
    Desc = "How high to float above targets",
    Step = 1,
    Value = {
        Min = 5,
        Max = 50,
        Default = 15,
    },
    Callback = function(value)
        Settings.HeightOffset = value
        print("[HEIGHT] Set to:", value, "studs")
        WindUI:Notify({
            Title = "Height Offset",
            Content = "Set to " .. value .. " studs",
            Duration = 2,
            Icon = "check",
        })
    end
})

CombatTab:Space()

local StatsSection = CombatTab:Section({
    Title = "Statistics",
    Icon = "bar-chart-2",
})

local StatsParagraph = CombatTab:Paragraph({
    Title = "Kill Statistics",
    Desc = "Total Kills: 0\n\nKills by Rarity:\n‚Ä¢ Unknown: 0",
    Color = "Blue",
    Image = "",
    ImageSize = 30,
    Thumbnail = "",
    ThumbnailSize = 80,
    Locked = false,
    Buttons = {}
})

local function updateStats()
    local statsText = string.format("Total Kills: %d\n\nKills by Rarity:", totalKills)
   
    for rarity, count in pairs(rarityKills) do
        statsText = statsText .. string.format("\n‚Ä¢ %s: %d", rarity, count)
    end
   
    if StatsParagraph and StatsParagraph.SetDesc then
        StatsParagraph:SetDesc(statsText)
    else
        -- Fallback: recreate or assume library supports
        print(statsText)
    end
end

-- Update stats every 2 seconds
task.spawn(function()
    while true do
        task.wait(2)
        updateStats()
    end
end)

local ResetButton = CombatTab:Button({
    Title = "Reset Statistics",
    Desc = "Clear all kill counts",
    Locked = false,
    Callback = function()
        totalKills = 0
        rarityKills = {}
        updateStats()
        print("[STATS] Reset!")
        WindUI:Notify({
            Title = "Stats Reset",
            Content = "All kill counts cleared",
            Duration = 2,
            Icon = "refresh-cw",
        })
    end
})

CombatTab:Space()

--// Combined Tool Copier & Plant Spawner

local SpawnTab = Window:Tab({
    Title = "Spawner",
    Icon = "box",
    Locked = false,
})

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local backpack = player.Backpack
local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer.Backpack

-- ================================
-- TOOL COPIER SECTION
-- ================================

local ToolCopierSection = SpawnTab:Section({
    Title = "Tool Copier",
    Icon = "package",
})

-- Asset paths to copy from
local assetPaths = {
	{name = "Seeds", path = ReplicatedStorage.Assets.Seeds},
	{name = "Eggs", path = ReplicatedStorage.Assets.Eggs},
	{name = "Crates", path = ReplicatedStorage.Assets.Crates},
	{name = "Bats", path = ReplicatedStorage.Assets.Bats}
}

-- Function to get all tool names from a path
local function getToolNames(path)
	local toolNames = {}
	if not path then return toolNames end
	
	for _, item in pairs(path:GetChildren()) do
		if item:IsA("Tool") then
			table.insert(toolNames, item.Name)
		end
	end
	return toolNames
end

-- Function to copy tool to backpack
local function copyToolToBackpack(tool)
	if tool:IsA("Tool") then
		local clone = tool:Clone()
		clone.Parent = backpack
		return true
	end
	return false
end

-- Function to copy multiple tools by name
local function copyToolsByNames(path, toolNames)
	local copied = 0
	local failed = 0
	
	for _, toolName in pairs(toolNames) do
		local tool = path:FindFirstChild(toolName)
		if tool and copyToolToBackpack(tool) then
			copied = copied + 1
		else
			failed = failed + 1
		end
		wait(0.05)
	end
	
	return copied, failed
end

-- Create sections and components for each tool category
for _, categoryData in ipairs(assetPaths) do
	local Section = SpawnTab:Section({
		Title = categoryData.name,
		Icon = "box",
	})
	
	-- Get all tool names for this category
	local toolNames = getToolNames(categoryData.path)
	
	-- Create dropdown to select tools
	local Dropdown = Section:Dropdown({
		Title = categoryData.name .. " Items",
		Desc = "Select items to copy from " .. categoryData.name,
		Values = toolNames,
		Value = {},
		Multi = true,
		AllowNone = true,
		Callback = function(options)
			print(categoryData.name .. " selected: " .. game:GetService("HttpService"):JSONEncode(options))
		end
	})
	
	-- Create Copy Selected button
	local CopySelectedBtn = Section:Button({
		Title = "Copy Selected " .. categoryData.name,
		Desc = "Copy only the selected items from " .. categoryData.name,
		Locked = false,
		Callback = function()
			local selectedTools = Dropdown.Value or {}
			
			if #selectedTools == 0 then
				print("No tools selected from " .. categoryData.name)
				return
			end
			
			print("Copying " .. categoryData.name .. " items...")
			
			local copied, failed = copyToolsByNames(categoryData.path, selectedTools)
			
			print("‚úÖ Copied " .. copied .. " tools from " .. categoryData.name)
			if failed > 0 then
				print("(" .. failed .. " failed)")
			end
		end
	})
	
	-- Create Copy All button for this category
	local CopyAllBtn = Section:Button({
		Title = "Copy All " .. categoryData.name,
		Desc = "Copy all items from " .. categoryData.name,
		Locked = false,
		Callback = function()
			print("Copying all " .. categoryData.name .. "...")
			
			local copied = 0
			local failed = 0
			
			for _, item in pairs(categoryData.path:GetChildren()) do
				if copyToolToBackpack(item) then
					copied = copied + 1
				else
					failed = failed + 1
				end
				wait(0.05)
			end
			
			print("‚úÖ Copied " .. copied .. " tools from " .. categoryData.name)
			if failed > 0 then
				print("(" .. failed .. " failed)")
			end
		end
	})
end

-- Create a Master Controls section
local MasterSection = SpawnTab:Section({
	Title = "Master Controls",
	Icon = "settings",
})

-- Copy Everything button
local CopyEverythingBtn = MasterSection:Button({
	Title = "Copy Everything",
	Desc = "Copy all tools from all categories",
	Locked = false,
	Callback = function()
		print("Copying all categories...")
		
		local totalCopied = 0
		local totalFailed = 0
		
		for _, categoryData in ipairs(assetPaths) do
			for _, item in pairs(categoryData.path:GetChildren()) do
				if copyToolToBackpack(item) then
					totalCopied = totalCopied + 1
				else
					totalFailed = totalFailed + 1
				end
				wait(0.05)
			end
		end
		
		print("‚úÖ Copied " .. totalCopied .. " total tools!")
		if totalFailed > 0 then
			print("(" .. totalFailed .. " failed)")
		end
	end
})

-- ================================
-- PLANT SPAWNER SECTION
-- ================================

local ControlSectionSpawner = SpawnTab:Section({
    Title = "Plant Spawner",
    Icon = "seedling",
})

-- Weight variable (default value)
local toolWeight = 11.3

-- Function to convert model to tool
local function convertModelToTool(model, toolName)
    if not model then
        warn("Model not found!")
        return nil
    end
    
    local tool = Instance.new("Tool")
    -- Format tool name with weight
    tool.Name = string.format("[%.1f kg] %s", toolWeight, toolName or model.Name)
    tool.RequiresHandle = true
    tool.CanBeDropped = true
    tool.Grip = CFrame.new(0, 0, 0)
    
    -- Create a centered handle at origin
    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(0.5, 0.5, 0.5)
    handle.Position = Vector3.new(0, 0, 0)
    handle.Transparency = 1
    handle.CanCollide = false
    handle.Anchored = false
    handle.Parent = tool
    
    -- Get model's bounding box center
    local modelCFrame, modelSize = model:GetBoundingBox()
    
    -- Clone all parts from the model
    for _, child in pairs(model:GetDescendants()) do
        if child:IsA("BasePart") or child:IsA("MeshPart") then
            local clonedChild = child:Clone()
            
            -- Clear all existing welds/constraints
            for _, constraint in pairs(clonedChild:GetChildren()) do
                if constraint:IsA("Constraint") or constraint:IsA("JointInstance") then
                    constraint:Destroy()
                end
            end
            
            clonedChild.Parent = tool
            clonedChild.CanCollide = false
            clonedChild.Anchored = false
            clonedChild.Massless = true
            
            -- Calculate offset from model center and apply to handle
            local offset = child.CFrame:ToObjectSpace(modelCFrame)
            clonedChild.CFrame = handle.CFrame * offset:Inverse()
            
            -- Weld to handle
            local weld = Instance.new("Weld")
            weld.Part0 = handle
            weld.Part1 = clonedChild
            weld.C0 = CFrame.new(0, 0, 0)
            weld.C1 = clonedChild.CFrame:ToObjectSpace(handle.CFrame)
            weld.Parent = handle
        end
    end
    
    -- Clone non-part children (meshes, textures, etc)
    for _, child in pairs(model:GetDescendants()) do
        if not child:IsA("BasePart") and not child:IsA("MeshPart") and 
           not child:IsA("Script") and not child:IsA("LocalScript") and
           not child:IsA("ModuleScript") then
            pcall(function()
                local clone = child:Clone()
                -- Find the parent part in the tool
                local parentPart = tool:FindFirstChild(child.Parent.Name)
                if parentPart then
                    clone.Parent = parentPart
                end
            end)
        end
    end
    
    return tool
end

-- Function to scan and get all models from a folder
local function scanFolder(folder, depth)
    depth = depth or 0
    local models = {}
    
    if not folder then return models end
    
    for _, child in pairs(folder:GetChildren()) do
        if child:IsA("Model") then
            table.insert(models, {
                Name = child.Name,
                Path = child:GetFullName(),
                Object = child,
                Depth = depth
            })
        elseif child:IsA("Folder") then
            -- Recursively scan subfolders
            local subModels = scanFolder(child, depth + 1)
            for _, model in pairs(subModels) do
                table.insert(models, model)
            end
        end
    end
    
    return models
end

-- Get all models from ReplicatedStorage.Assets.Plants
local function getModelList()
    local assetsPath = ReplicatedStorage:FindFirstChild("Assets")
    local plantsPath = assetsPath and assetsPath:FindFirstChild("Plants")
    
    if not plantsPath then
        warn("Path 'ReplicatedStorage.Assets.Plants' not found!")
        return {}, {}
    end
    
    local models = scanFolder(plantsPath, 0)
    local modelNames = {}
    
    for _, modelData in ipairs(models) do
        table.insert(modelNames, modelData.Name)
    end
    
    return models, modelNames
end

-- Store model data
local allModels, modelNames = getModelList()
local selectedModels = {}

-- Weight Input Field
local WeightInput = SpawnTab:Input({
    Title = "Weight (kg)",
    Desc = "Enter weight in kg",
    Value = "11.3",
    InputIcon = "weight",
    Type = "Input",
    Placeholder = "Enter weight in kg...",
    Callback = function(input)
        local weight = tonumber(input)
        if weight and weight > 0 then
            toolWeight = weight
            print("Tool weight set to: " .. weight .. " kg")
        else
            warn("Invalid weight! Please enter a positive number.")
        end
    end
})

-- Create dropdown for model selection
local SpawnDropdown = SpawnTab:Dropdown({
    Title = "Select Plant to Spawn",
    Values = modelNames,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedModels = options
        print("Selected models: " .. game:GetService("HttpService"):JSONEncode(options))
    end
})

-- Create spawn button
local SpawnButton = SpawnTab:Button({
    Title = "Spawn Selected Plant",
    Desc = "Spawns the selected Plant",
    Locked = false,
    Callback = function()
        local spawnedCount = 0
        
        for _, modelName in pairs(selectedModels) do
            -- Find the model in our list
            for _, modelData in pairs(allModels) do
                if modelData.Name == modelName then
                    local success, result = pcall(function()
                        local tool = convertModelToTool(modelData.Object:Clone(), modelData.Name)
                        if tool then
                            tool.Parent = Backpack
                            spawnedCount = spawnedCount + 1
                        end
                    end)
                    
                    if not success then
                        warn("Failed to spawn " .. modelName .. ": " .. tostring(result))
                    end
                    break
                end
            end
        end
        
        print("Spawned " .. spawnedCount .. " tool(s) with weight: " .. toolWeight .. " kg")
        
        -- Fire notification with item name and weight
        local Notification = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Notification")
        if Notification then
            firesignal(Notification.OnClientEvent, 
                {
                    Color = Color3.fromRGB(255, 0, 248),
                    Text = "Fryzer: " .. table.concat(selectedModels, ", ") .. " + " .. toolWeight .. " KG"
                }
            )
        end
    end
})

print("===========================================")
print("‚úÖ Combined Spawner Loaded!")
print("üì¶ Tool Copier: Seeds, Eggs, Crates, Bats")
print("üå± Plant Spawner: ReplicatedStorage.Assets.Plants")
print("===========================================")

local TpTab = Window:Tab({
    Title = "Teleport",
    Icon = "map-pin",
    Locked = false,
})

local ButtonTp1 = TpTab:Button({
    Title = "Teleport to Plot 1",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["1"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonTp2 = TpTab:Button({
    Title = "Teleport to Plot 2",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["2"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonTp3 = TpTab:Button({
    Title = "Teleport to Plot 3",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["3"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonTp4 = TpTab:Button({
    Title = "Teleport to Plot 4",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["4"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonTp5 = TpTab:Button({
    Title = "Teleport to Plot 5",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["5"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonTp6 = TpTab:Button({
    Title = "Teleport to Plot 6",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = workspace.Plots["6"].Origin
            if targetPart and targetPart:IsA("BasePart") then
                character.HumanoidRootPart.CFrame = targetPart.CFrame
                print("Teleported to Plot 1 Origin")
            else
                print("Target part not found!")
            end
        else
            print("Character not loaded!")
        end
    end
})

local ButtonEvnt = TpTab:Button({
    Title = "Teleport to Event area",
    Desc = "",
    Locked = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
        
        -- Teleport to the specified Vector3 position
        humanoidRootPart.CFrame = CFrame.new(Vector3.new(-173.81, 17.61, 978.32))
        
        print("Teleported")
    end
})


--// Seed Stock Notifier - UI Version

local NotifierTab = Window:Tab({
    Title = "Seed Notifier",
    Icon = "bell",
    Locked = false,
})

-- All available seeds
local allSeeds = {
	"Cactus Seed",
	"Watermelon Seed",
	"Tomatrio Seed",
	"Sunflower Seed",
	"Strawberry Seed",
	"Shroombino Seed",
	"Pumpkin Seed",
	"Mr Carrot Seed",
	"Mango Seed",
	"King Limone Seed",
	"Grape Seed",
	"Eggplant Seed",
	"Dragon Fruit Seed",
	"Cocotank Seed",
	"Carnivorous Plant Seed",
	"Starfruit Seed"
}

-- Color options for embed
local colorOptions = {
	"Red",
	"Blue",
	"Green",
	"Yellow",
	"Purple",
	"Orange",
	"Pink",
	"Cyan"
}

local colorMap = {
	["Red"] = 16711680,
	["Blue"] = 255,
	["Green"] = 65280,
	["Yellow"] = 16776960,
	["Purple"] = 9109504,
	["Orange"] = 16744448,
	["Pink"] = 16711935,
	["Cyan"] = 65535
}

-- Variables
local webhook = ""
local notifierTitle = "üå± Seed Stock Alert"
local selectedSeeds = {}
local selectedColor = "Blue"
local running = false
local lastSentTime = "Never"
local nextRestockTime = "--:--"
local hasSent458 = false

-- Function to get seed stock data
local function getSeedStockData(seeds)
	local player = game:GetService("Players").LocalPlayer
	local basePath = player.PlayerGui.Main.Seeds.Frame.ScrollingFrame
	
	local stockData = {}
	for _, seedName in ipairs(seeds) do
		local success, stock = pcall(function()
			return basePath[seedName].Stock.Text
		end)
		
		if success then
			table.insert(stockData, "*" .. seedName .. ":* " .. stock)
		else
			table.insert(stockData, "*" .. seedName .. ":* ‚ùå Not Found")
		end
	end
	
	return table.concat(stockData, "\n")
end

-- Function to send notification
local function sendNotification(restockTime)
	if webhook == "" then
		print("‚ùå Webhook URL not set!")
		return
	end
	
	local sedsToSend = #selectedSeeds > 0 and selectedSeeds or allSeeds
	local stockInfo = getSeedStockData(sedsToSend)
	local timestamp = os.date("%I:%M:%S %p")
	local embedColor = colorMap[selectedColor] or 255
	
	local data = {
		["embeds"] = {{
			["title"] = notifierTitle,
			["description"] = stockInfo,
			["color"] = embedColor,
			["footer"] = {
				["text"] = "Alert sent at " .. timestamp .. " | By Fryzer"
			}
		}}
	}

	local success, err = pcall(function()
		request({
			Url = webhook,
			Method = "POST",
			Headers = {["Content-Type"] = "application/json"},
			Body = game:GetService("HttpService"):JSONEncode(data)
		})
	end)

	if success then
		lastSentTime = timestamp .. " (at 04:57)"
		hasSent458 = true
		print("‚úÖ Notification sent!")
	else
		warn("‚ùå Notifier Error:", err)
	end
end

-- Function to check restock timer
local function checkRestockTimer()
	local player = game:GetService("Players").LocalPlayer
	local success, restockText = pcall(function()
		return player.PlayerGui.Main.Seeds.Restock.Text
	end)
	
	if success and restockText then
		nextRestockTime = restockText:match("New seeds in (.+)") or restockText
		
		if restockText:match("04:57") then
			if not hasSent458 then
				sendNotification(restockText)
			end
		else
			if hasSent458 then
				hasSent458 = false
			end
		end
	else
		nextRestockTime = "‚ùå Not Found"
	end
end

-- Webhook Input
pcall(function()
	local WebhookInput = NotifierTab:Input({
		Title = "Webhook URL",
		Desc = "Enter your Discord webhook URL",
		Placeholder = "https://discord.com/api/webhooks/...",
		Callback = function(input)
			webhook = input
			print("‚úÖ Webhook set!")
		end
	})
end)

-- Title Input
pcall(function()
	local TitleInput = NotifierTab:Input({
		Title = "Notification Title",
		Placeholder = "Seed Stock Alert",
		Callback = function(input)
			if input and input ~= "" then
				notifierTitle = input
			else
				notifierTitle = "Seed Stock Alert"
			end
			print("‚úÖ Title updated!")
		end
	})
end)

-- Color Dropdown
local ColorDropdown = NotifierTab:Dropdown({
	Title = "Embed Color",
	Desc = "Choose embed color for Discord message",
	Values = colorOptions,
	Value = "Blue",
	Callback = function(option)
		selectedColor = option
		print("‚úÖ Color set to: " .. option)
	end
})

-- Seeds Dropdown
local SeedsDropdown = NotifierTab:Dropdown({
	Title = "Seeds to Monitor",
	Desc = "Select which seeds to include in notifications",
	Values = allSeeds,
	Value = {},
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedSeeds = options
		print("‚úÖ Seeds selected!")
	end
})

-- Main Toggle
local MainToggle = NotifierTab:Toggle({
	Title = "Enable Notifier",
	Desc = "Start/Stop monitoring restock timer",
	Icon = "power",
	Default = false,
	Callback = function(state)
		running = state
		if running then
			hasSent458 = false
			print("‚úÖ Seed notifier started!")
		else
			print("‚ùå Seed notifier stopped!")
		end
	end
})

-- Main monitoring loop
spawn(function()
	while true do
		wait(0.5)
		
		if running then
			checkRestockTimer()
		else
			wait(1)
		end
	end
end)

print("‚úÖ Seed Stock Notifier UI loaded!")
print("üìã Configure webhook, title, and seeds")
print("üå± Select seeds and enable to start monitoring")

-- All available gears
local allGears = {
	"Water Bucket",
	"Frost Grenade",
	"Frost Blower",
	"Carrot Launcher",
	"Banana Gun"
}

-- Divider for Gear Section
NotifierTab:Divider()

-- Variables for Gears
local gearWebhook = ""
local gearTitle = "‚öôÔ∏è Gear Stock Alert"
local selectedGears = {}
local gearSelectedColor = "Blue"
local gearRunning = false
local gearLastSentTime = "Never"
local gearNextRestockTime = "--:--"
local gearHasSent458 = false

-- Function to get gear stock data
local function getGearStockData(gears)
	local player = game:GetService("Players").LocalPlayer
	local basePath = player.PlayerGui.Main.Gears.Frame.ScrollingFrame
	
	local stockData = {}
	for _, gearName in ipairs(gears) do
		local success, stock = pcall(function()
			return basePath[gearName].Stock.Text
		end)
		
		if success then
			table.insert(stockData, "*" .. gearName .. ":* " .. stock)
		else
			table.insert(stockData, "*" .. gearName .. ":* ‚ùå Not Found")
		end
	end
	
	return table.concat(stockData, "\n")
end

-- Function to send gear notification
local function sendGearNotification(restockTime)
	if gearWebhook == "" then
		print("‚ùå Gear Webhook URL not set!")
		return
	end
	
	local gearsToSend = #selectedGears > 0 and selectedGears or allGears
	local stockInfo = getGearStockData(gearsToSend)
	local timestamp = os.date("%I:%M:%S %p")
	local embedColor = colorMap[gearSelectedColor] or 255
	
	local data = {
		["embeds"] = {{
			["title"] = gearTitle,
			["description"] = stockInfo,
			["color"] = embedColor,
			["footer"] = {
				["text"] = "Alert sent at " .. timestamp .. " | By Fryzer"
			}
		}}
	}

	local success, err = pcall(function()
		request({
			Url = gearWebhook,
			Method = "POST",
			Headers = {["Content-Type"] = "application/json"},
			Body = game:GetService("HttpService"):JSONEncode(data)
		})
	end)

	if success then
		gearLastSentTime = timestamp .. " (at 04:57)"
		gearHasSent458 = true
		print("‚úÖ Gear notification sent!")
	else
		warn("‚ùå Gear Notifier Error:", err)
	end
end

-- Function to check gear restock timer
local function checkGearRestockTimer()
	local player = game:GetService("Players").LocalPlayer
	local success, restockText = pcall(function()
		return player.PlayerGui.Main.Gears.Restock.Text
	end)
	
	if success and restockText then
		gearNextRestockTime = restockText:match("New gears in (.+)") or restockText
		
		if restockText:match("04:57") then
			if not gearHasSent458 then
				sendGearNotification(restockText)
			end
		else
			if gearHasSent458 then
				gearHasSent458 = false
			end
		end
	else
		gearNextRestockTime = "‚ùå Not Found"
	end
end

-- Gear Webhook Input
pcall(function()
	local GearWebhookInput = NotifierTab:Input({
		Title = "Gear Webhook URL",
		Desc = "Enter your Discord webhook URL for gears",
		Placeholder = "https://discord.com/api/webhooks/...",
		Callback = function(input)
			gearWebhook = input
			print("‚úÖ Gear Webhook set!")
		end
	})
end)

-- Gear Title Input
pcall(function()
	local GearTitleInput = NotifierTab:Input({
		Title = "Gear Notification Title",
		Placeholder = "Gear Stock Alert",
		Callback = function(input)
			if input and input ~= "" then
				gearTitle = input
			else
				gearTitle = "Gear Stock Alert"
			end
			print("‚úÖ Gear title updated!")
		end
	})
end)

-- Gear Color Dropdown
local GearColorDropdown = NotifierTab:Dropdown({
	Title = "Gear Embed Color",
	Desc = "Choose embed color for gear Discord message",
	Values = colorOptions,
	Value = "Blue",
	Callback = function(option)
		gearSelectedColor = option
		print("‚úÖ Gear color set to: " .. option)
	end
})

-- Gears Dropdown
local GearsDropdown = NotifierTab:Dropdown({
	Title = "Gears to Monitor",
	Desc = "Select which gears to include in notifications",
	Values = allGears,
	Value = {},
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedGears = options
		print("‚úÖ Gears selected!")
	end
})

-- Gear Main Toggle
local GearMainToggle = NotifierTab:Toggle({
	Title = "Enable Gear Notifier",
	Desc = "Start/Stop monitoring gear restock timer",
	Icon = "power",
	Default = false,
	Callback = function(state)
		gearRunning = state
		if state then
			gearHasSent458 = false
			print("‚úÖ Gear notifier started!")
		else
			print("‚ùå Gear notifier stopped!")
		end
	end
})

-- Gear monitoring loop
spawn(function()
	while true do
		wait(0.5)
		
		if gearRunning then
			checkGearRestockTimer()
		else
			wait(1)
		end
	end
end)

print("‚úÖ Gear Stock Notifier UI loaded!")
print("üìã Configure gear webhook, title, and gears")
print("‚öôÔ∏è Select gears and enable to start monitoring")
--

local MiscTab = Window:Tab({
    Title = "Misc",
    Icon = "folder",
    Locked = false,
})

local ToggleAntiAFK = MiscTab:Toggle({
    Title = "Anti AFK",
    Desc = "Prevents automatic idle kick",
    Icon = "shield-check",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        if state then
            local player = game.Players.LocalPlayer

            -- Disconnect existing idle connections if any
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
            end

            -- Connect to Idled event
            getgenv().AntiAFKConnection = player.Idled:Connect(function()
                -- simulate click or jump to prevent kick
                game:GetService("VirtualUser"):CaptureController()
                game:GetService("VirtualUser"):ClickButton2(Vector2.new())
                print("‚è± Anti-AFK triggered!")
            end)

            print("‚úÖ Anti-AFK enabled")
        else
            -- Disconnect Anti-AFK
            if getgenv().AntiAFKConnection then
                getgenv().AntiAFKConnection:Disconnect()
                getgenv().AntiAFKConnection = nil
            end
            print("‚õî Anti-AFK disabled")
        end
    end
})

local Buttonpowersave = MiscTab:Button({
    Title = "Power Save Mode",
    Desc = "Open Power Save Script",
    Locked = false,
    Callback = function()
        print("Opening Power Save Script...")
        loadstring(game:HttpGet("https://raw.githubusercontent.com/FryzerHub/SubScripts/refs/heads/main/screen%20saver"))()
    end
})

-- ==================== TAB 6: SETTINGS ====================
local Tab6 = Window:Tab({
    Title = "Settings",
    Icon = "settings",
    Locked = false,
})

local SettingsSection1 = Tab6:Section({
    Title = "Window Settings",
    Icon = "layout",
})

Tab6:Space()

-- Transparency Toggle
local TransparencyToggle = Tab6:Toggle({
    Title = "Window Transparency",
    Desc = "Toggle window transparency on/off",
    Icon = "eye",
    Type = "Checkbox",
    Default = false,
    Callback = function(state)
        Window:ToggleTransparency(state)
        print("Transparency: " .. tostring(state))
    end
})

Tab6:Divider()

local SettingsSection2 = Tab6:Section({
    Title = "Keybind Settings",
    Icon = "keyboard",
})

-- Input field for keybind
local KeybindInput = Tab6:Input({
    Title = "Toggle UI Keybind",
    Desc = "Type ONE letter or key (e.g., Q or RightControl)",
    Value = "RightControl",
    InputIcon = "keyboard",
    Type = "Input",
    Placeholder = "Enter key...",
    Callback = function(input)
        -- Trim whitespace
        input = input:gsub("^%s*(.-)%s*$", "%1")
        
        local keyCode
        
        -- Check if it's a single letter (case insensitive)
        if #input == 1 then
            local upperInput = input:upper()
            keyCode = Enum.KeyCode[upperInput]
        else
            -- Try as a full KeyCode name
            local success, result = pcall(function()
                return Enum.KeyCode[input]
            end)
            if success then
                keyCode = result
            end
        end
        
        if keyCode then
            Window:SetToggleKey(keyCode)
            print("Keybind set to: " .. input)
            WindUI:Notify({
                Title = "Keybind Updated",
                Content = "Press '" .. input .. "' to toggle UI",
                Duration = 3,
                Icon = "check",
            })
        else
            print("Invalid key: " .. input)
            WindUI:Notify({
                Title = "Invalid Key",
                Content = "Enter a single letter (Q) or key name (RightControl)",
                Duration = 4,
                Icon = "x",
            })
        end
    end
})

-- Set default toggle key
Window:SetToggleKey(Enum.KeyCode.RightControl)

Tab6:Space()

-- ==================== WINDOW LEVEL COMPONENTS ====================
Window:Space()

-- Final Notification
WindUI:Notify({
    Title = "All Components Loaded",
    Content = "Every component is now visible!",
    Duration = 5,
    Icon = "check-circle",
})

WindUI:Notify({
    Title = "Fryzer Hub Loaded",
    Content = "Script is ready to use!",
    Duration = 2.5,
    Icon = "check-circle",
})

Window:OnDestroy(function()
    stopKillAura()
    print("Window destroyed")
end)

-- Cleanup on script stop
game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
    stopKillAura()
end)
    

    local StarterGui = game:GetService("StarterGui")
    StarterGui:SetCore("SendNotification", {
        Title = "FRYZER HUB";
        Text = "Successfully loaded!";
        Duration = 5;
    })
end

--! Wait for game to load
repeat task.wait(1) until game:IsLoaded()

--! Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

--! Utility Functions
local fSetClipboard = setclipboard or toclipboard
local fRequest = request or http_request or syn_request

--! Date/Time Parsing Function (Indian Time Format)
local function parseIndianDate(dateString)
    -- Parse format: DD-MM-YYYY HH:MM (Indian Standard Time)
    -- Example: "31-12-2025 23:59"
    local pattern = "(%d+)-(%d+)-(%d+)%s+(%d+):(%d+)"
    local day, month, year, hour, min = dateString:match(pattern)
    
    if not day then
        return nil
    end
    
    -- Create time directly (Roblox os.time uses local system time)
    -- We treat the input as IST and compare directly
    local expiryTime = os.time({
        year = tonumber(year),
        month = tonumber(month),
        day = tonumber(day),
        hour = tonumber(hour),
        min = tonumber(min),
        sec = 59  -- Set to end of minute
    })
    
    return expiryTime
end

--! Key System Functions
local function checkSimpleKey(inputKey)
    local success, result = pcall(function()
        local response = fRequest({
            Url = KEY_CHECK_URL,
            Method = "GET"
        })
        
        if response.StatusCode == 200 then
            local validKeys = {}
            for key in string.gmatch(response.Body, "[^\r\n]+") do
                local cleanKey = string.gsub(key, "%s+", "")
                if cleanKey ~= "" then
                    table.insert(validKeys, cleanKey)
                end
            end
            
            local cleanInputKey = string.gsub(inputKey, "%s+", "")
            for _, validKey in ipairs(validKeys) do
                if cleanInputKey == validKey then
                    return true, "Key verified successfully!"
                end
            end
            
            return false, "Invalid key"
        else
            return false, "Failed to connect to key server"
        end
    end)
    
    if success then
        return result
    else
        return false, "Error checking key: " .. tostring(result)
    end
end

local function checkExpiryKey(inputKey)
    local success, result = pcall(function()
        local response = fRequest({
            Url = EXPIRY_CHECK_URL,
            Method = "GET"
        })
        
        if response.StatusCode == 200 then
            local data = HttpService:JSONDecode(response.Body)
            
            if not data.keys then
                return false, "Invalid expiry key data format"
            end
            
            local cleanInputKey = string.gsub(inputKey, "%s+", "")
            local currentTime = os.time()
            
            for _, keyData in ipairs(data.keys) do
                local cleanKey = string.gsub(keyData.key, "%s+", "")
                
                if cleanInputKey == cleanKey then
                    -- Found matching key, now check expiry
                    local expiryTime = parseIndianDate(keyData.expiry)
                    
                    if not expiryTime then
                        return false, "Invalid date format (use DD-MM-YYYY HH:MM)"
                    end
                    
                    if currentTime > expiryTime then
                        return false, "Key has expired"
                    end
                    
                    -- Key is valid and not expired
                    local secondsLeft = expiryTime - currentTime
                    local daysLeft = math.floor(secondsLeft / 86400)
                    local hoursLeft = math.floor((secondsLeft % 86400) / 3600)
                    
                    if daysLeft > 0 then
                        return true, "Key verified! " .. daysLeft .. " days remaining"
                    else
                        return true, "Key verified! " .. hoursLeft .. " hours remaining"
                    end
                end
            end
            
            return false, "Key not found in expiry database"
        else
            return false, "Failed to connect to expiry server"
        end
    end)
    
    if success then
        return result
    else
        return false, "Error checking expiry key: " .. tostring(result)
    end
end

local function checkKey(inputKey)
    -- First try simple key check
    local simpleSuccess, simpleMessage = checkSimpleKey(inputKey)
    if simpleSuccess then
        return true, simpleMessage
    end
    
    -- If simple key fails, try expiry key check
    local expirySuccess, expiryMessage = checkExpiryKey(inputKey)
    if expirySuccess then
        return true, expiryMessage
    end
    
    -- Both failed, return the expiry message (more informative)
    return false, expiryMessage
end

--! GUI Creation
local GUI_SIZE = UDim2.new(0, 400, 0, 220)
local BLACK = Color3.fromRGB(0, 0, 0)
local WHITE = Color3.fromRGB(255, 255, 255)
local DARK_GRAY = Color3.fromRGB(20, 20, 20)
local LIGHT_GRAY = Color3.fromRGB(240, 240, 240)
local MEDIUM_GRAY = Color3.fromRGB(128, 128, 128)

if playerGui:FindFirstChild("MinimalKeyGUI") then
    playerGui.MinimalKeyGUI:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MinimalKeyGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = GUI_SIZE
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -110)
mainFrame.BackgroundColor3 = BLACK
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

local borderFrame = Instance.new("Frame")
borderFrame.Name = "BorderFrame"
borderFrame.Size = UDim2.new(1, 6, 1, 6)
borderFrame.Position = UDim2.new(0, -3, 0, -3)
borderFrame.BackgroundColor3 = WHITE
borderFrame.BorderSizePixel = 0
borderFrame.ZIndex = -1
borderFrame.Parent = mainFrame

local titleSection = Instance.new("Frame")
titleSection.Name = "TitleSection"
titleSection.Size = UDim2.new(1, 0, 0, 60)
titleSection.Position = UDim2.new(0, 0, 0, 0)
titleSection.BackgroundColor3 = WHITE
titleSection.BorderSizePixel = 0
titleSection.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -40, 1, 0)
titleLabel.Position = UDim2.new(0, 20, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "FRYZER HUB"
titleLabel.TextColor3 = BLACK
titleLabel.TextSize = 24
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleSection

local separator = Instance.new("Frame")
separator.Name = "Separator"
separator.Size = UDim2.new(1, -40, 0, 1)
separator.Position = UDim2.new(0, 20, 1, -1)
separator.BackgroundColor3 = BLACK
separator.BorderSizePixel = 0
separator.Parent = titleSection

local contentFrame = Instance.new("Frame")
contentFrame.Name = "ContentFrame"
contentFrame.Size = UDim2.new(1, -40, 1, -80)
contentFrame.Position = UDim2.new(0, 20, 0, 70)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local statusLabel = Instance.new("TextLabel")
statusLabel.Name = "Status"
statusLabel.Size = UDim2.new(1, 0, 0, 20)
statusLabel.Position = UDim2.new(0, 0, 0, 0)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Enter your access key"
statusLabel.TextColor3 = WHITE
statusLabel.TextSize = 14
statusLabel.Font = Enum.Font.SourceSans
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = contentFrame

local inputContainer = Instance.new("Frame")
inputContainer.Name = "InputContainer"
inputContainer.Size = UDim2.new(1, 0, 0, 40)
inputContainer.Position = UDim2.new(0, 0, 0, 30)
inputContainer.BackgroundColor3 = BLACK
inputContainer.BorderSizePixel = 0
inputContainer.Parent = contentFrame

local inputBorder = Instance.new("Frame")
inputBorder.Name = "InputBorder"
inputBorder.Size = UDim2.new(1, 2, 1, 2)
inputBorder.Position = UDim2.new(0, -1, 0, -1)
inputBorder.BackgroundColor3 = WHITE
inputBorder.BorderSizePixel = 0
inputBorder.ZIndex = -1
inputBorder.Parent = inputContainer

local keyBox = Instance.new("TextBox")
keyBox.Name = "KeyBox"
keyBox.Size = UDim2.new(1, -20, 1, 0)
keyBox.Position = UDim2.new(0, 10, 0, 0)
keyBox.BackgroundTransparency = 1
keyBox.Text = ""
keyBox.PlaceholderText = "Paste key here..."
keyBox.TextColor3 = WHITE
keyBox.PlaceholderColor3 = MEDIUM_GRAY
keyBox.TextSize = 16
keyBox.Font = Enum.Font.SourceSans
keyBox.ClearTextOnFocus = false
keyBox.TextXAlignment = Enum.TextXAlignment.Left
keyBox.ClipsDescendants = true
keyBox.Parent = inputContainer

local buttonFrame = Instance.new("Frame")
buttonFrame.Name = "ButtonFrame"
buttonFrame.Size = UDim2.new(1, 0, 0, 40)
buttonFrame.Position = UDim2.new(0, 0, 0, 85)
buttonFrame.BackgroundTransparency = 1
buttonFrame.Parent = contentFrame

local function createButton(name, text, position, isBlack)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(0.3, -5, 1, 0)
    button.Position = position
    button.BackgroundColor3 = isBlack and BLACK or WHITE
    button.BorderSizePixel = 0
    button.Text = text
    button.TextColor3 = isBlack and WHITE or BLACK
    button.TextSize = 14
    button.Font = Enum.Font.SourceSansBold
    button.Parent = buttonFrame
    
    local buttonBorder = Instance.new("Frame")
    buttonBorder.Name = "Border"
    buttonBorder.Size = UDim2.new(1, 2, 1, 2)
    buttonBorder.Position = UDim2.new(0, -1, 0, -1)
    buttonBorder.BackgroundColor3 = isBlack and WHITE or BLACK
    buttonBorder.BorderSizePixel = 0
    buttonBorder.ZIndex = -1
    buttonBorder.Parent = button
    
    return button
end

local getKeyButton = createButton("GetKeyButton", "GET KEY", UDim2.new(0, 0, 0, 0), true)
local verifyButton = createButton("VerifyButton", "VERIFY", UDim2.new(0.35, 0, 0, 0), false)
local discordButton = createButton("DiscordButton", "DISCORD", UDim2.new(0.7, 0, 0, 0), true)

local progressContainer = Instance.new("Frame")
progressContainer.Name = "ProgressContainer"
progressContainer.Size = UDim2.new(1, 0, 0, 3)
progressContainer.Position = UDim2.new(0, 0, 1, -10)
progressContainer.BackgroundColor3 = DARK_GRAY
progressContainer.BorderSizePixel = 0
progressContainer.Visible = false
progressContainer.Parent = contentFrame

local progressBar = Instance.new("Frame")
progressBar.Name = "ProgressBar"
progressBar.Size = UDim2.new(0, 0, 1, 0)
progressBar.Position = UDim2.new(0, 0, 0, 0)
progressBar.BackgroundColor3 = WHITE
progressBar.BorderSizePixel = 0
progressBar.Parent = progressContainer

local function fadeText(element, transparency, duration)
    return TweenService:Create(
        element,
        TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad),
        {TextTransparency = transparency}
    )
end

local function updateStatus(message, isError, showProgress)
    statusLabel.Text = message
    statusLabel.TextColor3 = isError and LIGHT_GRAY or WHITE
    
    if showProgress then
        progressContainer.Visible = true
        progressBar.Size = UDim2.new(0, 0, 1, 0)
        
        local tween = TweenService:Create(
            progressBar,
            TweenInfo.new(2, Enum.EasingStyle.Linear),
            {Size = UDim2.new(1, 0, 1, 0)}
        )
        tween:Play()
        tween.Completed:Connect(function()
            task.wait(0.5)
            progressContainer.Visible = false
        end)
    else
        progressContainer.Visible = false
    end
end

local function setupButton(button, isBlack)
    local originalBg = button.BackgroundColor3
    local originalText = button.TextColor3
    local hoverBg = isBlack and DARK_GRAY or LIGHT_GRAY
    
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = hoverBg}):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = originalBg}):Play()
    end)
    
    button.MouseButton1Down:Connect(function()
        local flashTween = TweenService:Create(
            button,
            TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 0, true),
            {BackgroundColor3 = isBlack and WHITE or BLACK, TextColor3 = isBlack and BLACK or WHITE}
        )
        flashTween:Play()
    end)
end

keyBox.Focused:Connect(function()
    TweenService:Create(inputBorder, TweenInfo.new(0.2), {BackgroundColor3 = LIGHT_GRAY}):Play()
end)

keyBox.FocusLost:Connect(function(enterPressed)
    TweenService:Create(inputBorder, TweenInfo.new(0.2), {BackgroundColor3 = WHITE}):Play()
    if enterPressed then
        verifyButton.MouseButton1Click:Fire()
    end
end)

setupButton(getKeyButton, true)
setupButton(verifyButton, false)
setupButton(discordButton, true)

getKeyButton.MouseButton1Click:Connect(function()
    updateStatus("Opening get key page...", false, true)
    
    spawn(function()
        local success = pcall(function()
            fSetClipboard(GET_KEY_URL)
        end)
        
        if success then
            updateStatus("Get key link copied to clipboard!", false)
        else
            updateStatus("Get key link: " .. GET_KEY_URL, false)
        end
    end)
end)

verifyButton.MouseButton1Click:Connect(function()
    local key = keyBox.Text:gsub("%s+", "")
    
    if key == "" then
        updateStatus("Please enter a key", true)
        return
    end
    
    updateStatus("Verifying access...", false, true)
    
    spawn(function()
        local success, message = checkKey(key)
        
        if success then
            updateStatus("Access granted!", false)
            task.wait(1)
            
            local fadeOut = TweenService:Create(
                mainFrame,
                TweenInfo.new(0.5, Enum.EasingStyle.Quad),
                {BackgroundTransparency = 1}
            )
            
            local borderFadeOut = TweenService:Create(
                borderFrame,
                TweenInfo.new(0.5, Enum.EasingStyle.Quad),
                {BackgroundTransparency = 1}
            )
            
            local titleFadeOut = TweenService:Create(
                titleSection,
                TweenInfo.new(0.5, Enum.EasingStyle.Quad),
                {BackgroundTransparency = 1}
            )
            
            fadeOut:Play()
            borderFadeOut:Play()
            titleFadeOut:Play()
            fadeText(titleLabel, 1, 0.5):Play()
            fadeText(statusLabel, 1, 0.5):Play()
            
            fadeOut.Completed:Connect(function()
                screenGui:Destroy()
                executeMainScript()
            end)
        else
            updateStatus(message or "Invalid key", true)
        end
    end)
end)

discordButton.MouseButton1Click:Connect(function()
    updateStatus("Opening Discord invite...", false, true)
    
    spawn(function()
        local success = pcall(function()
            fSetClipboard(DISCORD_INVITE)
        end)
        
        if success then
            updateStatus("Discord invite copied to clipboard!", false)
        else
            updateStatus("Discord: " .. DISCORD_INVITE, false)
        end
    end)
end)

mainFrame.BackgroundTransparency = 1
titleSection.BackgroundTransparency = 1
borderFrame.BackgroundTransparency = 1
titleLabel.TextTransparency = 1
statusLabel.TextTransparency = 1

TweenService:Create(mainFrame, TweenInfo.new(0.4), {BackgroundTransparency = 0}):Play()
TweenService:Create(titleSection, TweenInfo.new(0.4), {BackgroundTransparency = 0}):Play()
TweenService:Create(borderFrame, TweenInfo.new(0.4), {BackgroundTransparency = 0}):Play()

task.wait(0.1)
fadeText(titleLabel, 0, 0.3):Play()
task.wait(0.1)
fadeText(statusLabel, 0, 0.3):Play()

updateStatus("Enter your access key", false)

print("[FRYZER HUB] Key system loaded successfully!")
print("[FRYZER HUB] Dual verification system active!")
print("[FRYZER HUB] Simple keys + Expiry keys supported!")
